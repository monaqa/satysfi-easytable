@require: math
@import: matrix

module EasyEqn : sig

  direct +align   : [(inline-text list)?; math list] block-cmd
  % direct \align   : [math list] inline-cmd
  % direct \aligned : [math list] math-cmd
  direct +alignat   : [int; math list] block-cmd
  % direct \alignat   : [int; math list] inline-cmd
  % direct \alignedat : [int; math list] math-cmd

  direct \matrix  : [int; math list] math-cmd
  direct \pmatrix : [int; math list] math-cmd
  direct \bmatrix : [int; math list] math-cmd
  direct \vmatrix : [int; math list] math-cmd
  direct \dmatrix : [int; math list] math-cmd

  % TODO: label を付ける
  %      （slydifi の fig-right と同じ原理でやるといい？）

end = struct

  % let convenient-nth idx lst =
  %   if idx >= 0 then
  %     lst |> List.nth idx
  %   else
  %     lst |> List.reverse |> List.nth (-idx - 1)
  %
  % let range n1 n2 =
  %   let-rec aux min max =
  %     if min == max then [min] else min :: (aux (min + 1) max)
  %   in
  %   if n1 < n2 then (aux n1 n2) else (aux n2 n1)
  %
  % let labelf : inline-boxes list -> length -> length list -> length list -> graphics list
  %   | lst-label abs-x-pos xs ys =
  %   let labelf-one yidx =
  %     let label = lst-label |> convenient-nth yidx in
  %     let y = ys |> convenient-nth (yidx + 1) in
  %     match (label, y) with
  %     | (Some(label), Some(y)) ->
  %         let y-adj = y +' 4pt in
  %         [draw-text (abs-x-pos, y-adj) label]
  %     | _ -> []
  %   in
  %   let len-label = List.length lst-label in
  %
  %   List.concat (List.map labelf-one (range 0 (len-label - 1)))

  let-rec map-each f-lst lst =
    match f-lst with
    | [] -> []
    | f1::fs -> (match lst with
                 | [] -> []
                 | x1::xs ->  (f1 x1) :: (map-each fs xs))

  let math-to-aligned-ib ctx idx m mprevopt mnextopt =
    let lengap = get-font-size ctx *' 2. in

    let ibm = embed-math ctx m in
    let ib =
      match mnextopt with
      | None -> ibm
      | Some(mnext) ->
          let ibspaceopt = space-between-maths ctx m mnext in
          ( match ibspaceopt with
            | None          -> ibm
            | Some(ibspace) -> ibm ++ ibspace
          )
    in

    if idx mod 2 == 0 then
      inline-fil ++ ib
    else
      match mnextopt with
      | None    -> ib ++ inline-fil
      | Some(_) -> ib ++ inline-fil ++ inline-skip lengap

  let create-max-height-vphantom lst-ib inner =
    % inline-boxes のリストに対し，それらの最大の高さ/最大の深さを求め，
    % それらをそれぞれ高さ・深さにもつよう加工した inline-boxes を返す．
    % ただし， width は 0 とする．
    let maximum len1 len2 = if len1 >' len2 then len1 else len2 in
    let get-natural-height ib = let (_, h, _) = get-natural-metrics ib in h in
    let get-natural-depth  ib = let (_, _, d) = get-natural-metrics ib in d in
    let max-height = List.fold-right maximum 0pt (List.map get-natural-height lst-ib) in
    let max-depth = List.fold-right maximum 0pt (List.map get-natural-depth lst-ib) in

    let (w, _, _) = get-natural-metrics inner in
    inline-graphics 0pt max-height max-depth (fun (x, y) -> [
      draw-text (x -' w, y) inner
    ])

  let-block ctx +align ?:it-lst-label-opt mlst =
    let it-lst-label =
      match it-lst-label-opt with
      | Some(itlst) -> itlst
      | None -> {| |}
    in
    let vlen = 4pt in

    let math-matrix = Matrix.from-list 2 ${} mlst in
    let ib-matrix = Matrix.map-rowidx-adjacent (math-to-aligned-ib ctx) math-matrix in

    let cell-matrix =
      Matrix.map (fun ib -> NormalCell((0pt, 0pt, vlen, vlen), ib)) ib-matrix
    in

    % Label 表示用のテーブル（右端に置いて複数行に渡るラベルを実現する）
    let ib-lst-label = List.map (read-inline ctx) it-lst-label in
    let max-height-vphantom-f = List.map create-max-height-vphantom (Matrix.to-llist ib-matrix) in
    let dummy-ib = read-inline ctx {} in
    let ib-phantom-label-matrix = Matrix.from-list 1 dummy-ib (map-each max-height-vphantom-f ib-lst-label) in
    let cell-label-matrix =
      Matrix.map (fun ib -> NormalCell((0pt, 0pt, vlen, vlen), ib)) ib-phantom-label-matrix
    in

    % let rulef = (labelf [read-inline ctx {hose}; read-inline ctx {fuga}] 300pt) in
    let rulef _ _ = [] in
    let ib-tabular = tabular (Matrix.to-llist cell-matrix) rulef in
    let ib-label-tabular = tabular (Matrix.to-llist cell-label-matrix) rulef in

    let margin = get-font-size ctx *' 1.0 in
    let ctx-eqn = ctx |> set-paragraph-margin margin margin in
    line-break true true ctx-eqn (inline-fil ++ ib-tabular ++ inline-fil ++ ib-label-tabular)


  let-block ctx +alignat ncol mlst =

    let vlen = 4pt in

    let math-matrix = Matrix.from-list (ncol * 2) ${} mlst in
    let ib-matrix = Matrix.map-rowidx-adjacent (math-to-aligned-ib ctx) math-matrix in

    let cell-matrix =
      Matrix.map (fun ib -> NormalCell((0pt, 0pt, vlen, vlen), ib)) ib-matrix
    in

    let rulef _ _ = [] in
    let ib-tabular = tabular (Matrix.to-llist cell-matrix) rulef in

    let margin = get-font-size ctx *' 1.0 in
    let ctx-eqn = ctx |> set-paragraph-margin margin margin in
    line-break true true ctx-eqn (inline-fil ++ ib-tabular ++ inline-fil)

  let matrix-body ncol mlst =
    let ib-func ctx =
      let fsize = ctx |> get-font-size in
      let pad-width = fsize *' 0.4 in
      let pad-height = fsize *' 0.25 in

      % まずは math list を列数が ncol になるよう並べた tabular を作る
      let math-matrix = Matrix.from-list ncol ${} mlst in
      let ib-matrix = Matrix.map (embed-math ctx) math-matrix in
      let ib-to-cell ib = 
        NormalCell(
          (pad-width, pad-width, pad-height, pad-height),
          inline-fil ++ ib ++ inline-fil
        )
      in
      let cell-matrix = Matrix.map ib-to-cell ib-matrix in
      let rulef _ _ = [] in
      let ib-tabular = tabular (Matrix.to-llist cell-matrix) rulef in

      let (tab-wid, tab-ht, tab-dp) = get-natural-metrics ib-tabular in
      % 多分 tab-dp は 0pt だけど念の為

      % 外側の padding を消すために強引なことをする:
      % inline-graphics で所望の大きさの inline-box を偽装し，
      % 中身は graphics の draw-text で位置を調整しつつ記述する
      let ib-tabular-adjusted =
        let vertical-length =  (tab-ht +' tab-dp) -' pad-height *' 2.0 in
        let axis-height = get-axis-height ctx in
        let adj-ht = axis-height +' vertical-length *' 0.5 in
        let adj-dp = vertical-length *' 0.5 -' axis-height in
        let adj-wid = tab-wid -' pad-width *' 2.0 in
        let text-drawer (x, y) =
          % 相対的な原点から見て table の開始点をどこに置くか
          let rel-origin-x = 0pt -' pad-width in
          let rel-origin-y = 0pt -' vertical-length *' (0.5) in
          [draw-text (x +' rel-origin-x, y +' rel-origin-y) ib-tabular]
        in
        inline-graphics adj-wid adj-ht adj-dp text-drawer in

      ib-tabular-adjusted

    in
    text-in-math MathInner ib-func

  let-math \matrix ncol mlst =
    matrix-body ncol mlst

  let-math \pmatrix ncol mlst =
    math-paren Math.paren-left Math.paren-right (matrix-body ncol mlst)

  let-math \bmatrix ncol mlst =
    math-paren Math.sqbracket-left Math.sqbracket-right (matrix-body ncol mlst)

  let-math \vmatrix ncol mlst =
    math-paren Math.abs-left Math.abs-right (matrix-body ncol mlst)

  let-math \dmatrix ncol mlst =
    math-paren Math.norm-left Math.norm-right (matrix-body ncol mlst)

end

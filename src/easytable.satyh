@require: list
@require: gr
@require: option
@require: color
@import: matrix

% 罫線のパターン．
type ruleptn = length list -> length list -> graphics list

% セルの書式
type cellfmt = context -> inline-text -> cell

module EasyTable: sig

% cell format
  val align-left   : cellfmt
  val align-center : cellfmt
  val align-right  : cellfmt
  val align-left-with-width   : length -> cellfmt
  val align-center-with-width : length -> cellfmt
  val align-right-with-width  : length -> cellfmt
  val equal-spacing : cellfmt
  val equal-spacing-with-width : length -> cellfmt

  val margin : length -> length -> cellfmt -> cellfmt

% rule pattern
  val genrule: (path -> graphics) -> (int * int) -> (int * int) -> ruleptn
  val toprule: ruleptn
  val bottomrule: ruleptn
  val midrule: int -> ruleptn
  val vertrule: int -> ruleptn
  val horizrule: int -> ruleptn
  val diagrule: (int * int) -> (int * int) -> ruleptn
  val outerframerule: ruleptn
  % val header-col-bg: color -> ruleptn
  val genbgcolor: color -> (int * int) -> (int * int) -> ruleptn
  val whole-bgcolor: color -> ruleptn
  val column-bgcolor: color -> int -> int -> ruleptn
  val row-bgcolor: color -> int -> int -> ruleptn

% commands
  direct \easytable: [(ruleptn list)?; (cellfmt list); (inline-text list)] inline-cmd
  direct \list-table: [(ruleptn list)?; (cellfmt list); itemize] inline-cmd

end = struct

% cell format

  let default-pads ctx =
    let fs = ctx |> get-font-size in
    (fs *' 0.5, fs *' 0.5, fs *' 0.4, fs *' 0.4)

  let align-left ctx it =
    NormalCell(default-pads ctx, (read-inline ctx it) ++ inline-fil)

  let align-center ctx it =
    NormalCell(default-pads ctx, inline-fil ++ (read-inline ctx it) ++ inline-fil)

  let align-right ctx it =
    NormalCell(default-pads ctx, inline-fil ++ (read-inline ctx it))

  let align-left-with-width wid ctx it =
    let ib = read-inline ctx it in
    let (wid-ib, _, _) = get-natural-metrics ib in
    if wid-ib >' wid then
      let ib-block = embed-block-top ctx wid
        (fun ctx1 -> line-break false false ctx1 (ib ++ inline-fil)) in
        NormalCell(default-pads ctx, ib-block)
    else
      let skp = inline-skip (wid -' wid-ib) in
      NormalCell(default-pads ctx, ib ++ skp ++ inline-fil)

  let align-center-with-width wid ctx it =
    let ib = read-inline ctx it in
    let (wid-ib, _, _) = get-natural-metrics ib in
    if wid-ib >' wid then
      let ib-block = embed-block-top ctx wid
        (fun ctx1 -> line-break false false ctx1 (ib ++ inline-fil)) in
        NormalCell(default-pads ctx, ib-block)
    else
      let skp = inline-skip ((wid -' wid-ib) *' 0.5) in
      NormalCell(default-pads ctx, inline-fil ++ skp ++ ib ++ skp ++ inline-fil)

  let align-right-with-width wid ctx it =
    let ib = read-inline ctx it in
    let (wid-ib, _, _) = get-natural-metrics ib in
    if wid-ib >' wid then
      let ib-block = embed-block-top ctx wid
        (fun ctx1 -> line-break false false ctx1 (ib ++ inline-fil)) in
        NormalCell(default-pads ctx, ib-block)
    else
      let skp = inline-skip (wid -' wid-ib) in
      NormalCell(default-pads ctx, inline-fil ++ skp ++ ib)

  let equal-spacing ctx it =
    let ib =
      let ctx1 = ctx |> set-space-ratio 0.33 0.08 1000.  in
      read-inline ctx1 it
    in
    NormalCell(default-pads ctx, ib)

  let equal-spacing-with-width wid ctx it =
    let ib =
      let ctx1 = ctx |> set-space-ratio 0.33 0.08 1000.  in
      embed-block-top ctx1 wid
        (fun ctx -> line-break false false ctx (read-inline ctx it))
    in
    NormalCell(default-pads ctx, ib)

  let margin l r cfmt ctx it =
    match cfmt ctx it with
      | NormalCell((pl, pr, pt, pb), ib) ->
          NormalCell((pl +' l, pr +' r, pt, pb), ib)
      | MultiCell(i, j, (pl, pr, pt, pb), ib) ->
          MultiCell(i, j, (pl +' l, pr +' r, pt, pb), ib)
      | EmptyCell -> EmptyCell

  let phantom cfmt ctx it =
    let phantomf ib =
      let (w, h, d) = get-natural-metrics ib in
      inline-graphics w h d (fun (x, y) -> [])
    in
    match cfmt ctx it with
      | NormalCell(pads, ib) ->
          NormalCell(pads, phantomf ib)
      | MultiCell(i, j, pads, ib) ->
          MultiCell(i, j, pads, phantomf ib)
      | EmptyCell -> EmptyCell

% rule pattern

  % 複数の罫線パターンを結合する．
  let-rec concat-ruleptn ruleptn-lst xs ys =
    match ruleptn-lst with
    | [] -> []
    | (ruleptn :: others) -> List.append (ruleptn xs ys) (concat-ruleptn others xs ys)

  % convenient-nth 0 lst だったら lst の最初の要素，
  % convenient-nth 1 lst だったら lst の最初から2番目の要素をとる．
  % convenient-nth -1 lst だったら lst の最後の要素，
  % convenient-nth -2 lst だったら lst の最後から2番目の要素をとる，
  % Python の index のようなイメージ．「ここから最後まで引きたい」ときに便利．
  let convenient-nth idx lst =
    if idx >= 0 then
      lst |> List.nth idx
    else
      lst |> List.reverse |> List.nth (-idx - 1)

  let genrule line-style (coli, rowi) (colj, rowj) xs ys =
    let xi = xs |> convenient-nth coli in
    let xj = xs |> convenient-nth colj in
    let yi = ys |> convenient-nth rowi in
    let yj = ys |> convenient-nth rowj in
    match (xi, xj, yi, yj) with
    | (Some(xi), Some(xj), Some(yi), Some(yj)) ->
        [line-style (Gr.line (xi, yi) (xj, yj))]
    | _ -> []

  let toprule = genrule (stroke 1pt Color.black) (0, 0) (-1, 0)
  let bottomrule = genrule (stroke 1pt Color.black) (0, -1) (-1, -1)
  let vertrule idx-col = genrule (stroke 0.5pt Color.black) (idx-col, 0) (idx-col, -1)
  let horizrule idx-row = genrule (stroke 0.5pt Color.black) (0, idx-row) (-1, idx-row)
  let diagrule = genrule (stroke 0.5pt Color.black)

  let midrule idx-row xs ys =
    % booktabs っぽくちょっと短いラインにしてみる
    let thin = stroke 0.5pt Color.black in
    let yi = ys |> convenient-nth idx-row in
    let x0 = xs |> convenient-nth 0 in
    let xlast = xs |> convenient-nth (-1) in
    match (yi, x0, xlast) with
    | (Some(yi), Some(x0), Some(xlast)) ->
        let x0-adj = x0 +' 2pt in
        let xlast-adj = xlast -' 2pt in
        [thin (Gr.line (x0-adj, yi) (xlast-adj, yi))]
    | _ -> []

  let outerframerule xs ys =
    % booktabs っぽくちょっと短いラインにしてみる
    let thick = stroke 1pt Color.black in
    let x0 = xs |> convenient-nth 0 in
    let xlast = xs |> convenient-nth (-1) in
    let y0 = ys |> convenient-nth 0 in
    let ylast = ys |> convenient-nth (-1) in
    match (x0, xlast, y0, ylast) with
    | (Some(x0), Some(xlast), Some(y0), Some(ylast)) ->
        [thick (Gr.rectangle (x0, y0) (xlast, ylast))]
    | _ -> []

  % let whole-bgcolor clr = genrule (fill clr) (0, 0) (-1, 0)
  let genbgcolor clr (x1, y1) (x2, y2) xs ys =
    % booktabs っぽくちょっと短いラインにしてみる
    let thick = stroke 1pt Color.black in
    let x0 = xs |> convenient-nth x1 in
    let xlast = xs |> convenient-nth x2 in
    let y0 = ys |> convenient-nth y1 in
    let ylast = ys |> convenient-nth y2 in
    match (x0, xlast, y0, ylast) with
    | (Some(x0), Some(xlast), Some(y0), Some(ylast)) ->
        [fill clr (Gr.rectangle (x0, y0) (xlast, ylast))]
    | _ -> []

  let whole-bgcolor clr = genbgcolor clr (0, 0) (-1, -1)
  let column-bgcolor clr i1 i2 = genbgcolor clr (i1, 0) (i2, -1)
  let row-bgcolor clr j1 j2 = genbgcolor clr (0, j1) (-1, j2)

  % header の背景塗りつぶし．
  % うまくいくかと思ったが，どうやら罫線の graphics は
  % 中身を並べた後に描画されているらしく，文字の上に長方形が重なってしまうためボツ．
  % let header-col-bg clr xs ys =
  %   let y0 = ys |> List.nth 0 in
  %   let y1 = ys |> List.nth 1 in
  %   let x0 = xs |> List.nth 0 in
  %   let xlast = xs |> List.reverse |> List.nth 0 in
  %   match (y0, y1, x0, xlast) with
  %   | (Some(y0), Some(y1), Some(x0), Some(xlast)) ->
  %       [fill clr (Gr.rectangle (x0, y0) (xlast, y1))]
  %   | _ -> []

% commands

  let-inline ctx \easytable ?:rules-lst-opt cfmtlst it-vector =
    let cell-converter-lst = cfmtlst |> List.map (fun f -> f ctx) in
    let phantom-cell-converter-lst = cfmtlst |> List.map phantom |> List.map (fun f -> f ctx) in
    let it-matrix = Matrix.from-list (List.length cfmtlst) {} it-vector in
    let cell-matrix = Matrix.colmap (cell-converter-lst) it-matrix in
    let phantom-cell-matrix = Matrix.colmap (phantom-cell-converter-lst) it-matrix in

    % 罫線の設定．
    let default-rules-lst = [toprule;bottomrule; midrule 1;] in
    let rules-lst = Option.from default-rules-lst rules-lst-opt in
    let rulef = concat-ruleptn rules-lst in

    let ib-rule = tabular (Matrix.to-llist phantom-cell-matrix) rulef in
    let ib-table = tabular (Matrix.to-llist cell-matrix) (fun _ _ -> []) in
    let (w, h, d) = get-natural-metrics ib-table in
    inline-graphics w h d (fun (x, y) -> [
      draw-text (x, y) ib-rule;
      draw-text (x, y) ib-table;
    ])


  let itemize-to-it-matrix (Item(_, lst-item)) =
    let itemize-to-it-vector (Item(it, lst-item)) =
      let extract-it-from-item (Item(it-inner, _)) = it-inner in
      let inner-items = List.map extract-it-from-item lst-item in
      inner-items
    in
    Matrix.from-llist(List.map itemize-to-it-vector lst-item)

  let-inline ctx \list-table ?:rules-lst-opt cfmtlst item =
    let cell-converter-lst = cfmtlst |> List.map (fun f -> f ctx) in
    let phantom-cell-converter-lst = cfmtlst |> List.map phantom |> List.map (fun f -> f ctx) in
    let it-matrix = itemize-to-it-matrix item in
    let cell-matrix = Matrix.colmap (cell-converter-lst) it-matrix in
    let phantom-cell-matrix = Matrix.colmap (phantom-cell-converter-lst) it-matrix in

    % 罫線の設定．
    let default-rules-lst = [toprule;bottomrule; midrule 1;] in
    let rules-lst = Option.from default-rules-lst rules-lst-opt in
    let rulef = concat-ruleptn rules-lst in

    let ib-rule = tabular (Matrix.to-llist phantom-cell-matrix) rulef in
    let ib-table = tabular (Matrix.to-llist cell-matrix) (fun _ _ -> []) in
    let (w, h, d) = get-natural-metrics ib-table in
    inline-graphics w h d (fun (x, y) -> [
      draw-text (x, y) ib-rule;
      draw-text (x, y) ib-table;
    ])

end


module EasyTableAlias : sig

  val l : cellfmt
  val c : cellfmt
  val r : cellfmt
  val e : cellfmt
  val lw : length -> cellfmt
  val cw : length -> cellfmt
  val rw : length -> cellfmt
  val ew : length -> cellfmt

  val t : ruleptn
  val b : ruleptn
  val m : int -> ruleptn
  val v : int -> ruleptn
  val h : int -> ruleptn
  val d : (int * int) -> (int * int) -> ruleptn

  val bg-a : color -> ruleptn
  val bg-r : color -> int -> int -> ruleptn
  val bg-c : color -> int -> int -> ruleptn

  val rect : ruleptn

end = struct

  let l = EasyTable.align-left
  let c = EasyTable.align-center
  let r = EasyTable.align-right
  let e = EasyTable.equal-spacing
  let lw = EasyTable.align-left-with-width
  let cw = EasyTable.align-center-with-width
  let rw = EasyTable.align-right-with-width
  let ew = EasyTable.equal-spacing-with-width

  let t = EasyTable.toprule
  let b = EasyTable.bottomrule
  let m = EasyTable.midrule
  let v = EasyTable.vertrule
  let h = EasyTable.horizrule
  let d = EasyTable.diagrule

  let rect = EasyTable.outerframerule

  let bg-a = EasyTable.whole-bgcolor
  let bg-r = EasyTable.row-bgcolor
  let bg-c = EasyTable.column-bgcolor

end
